import streamlit as st
import pandas as pd
import joblib
import plotly.express as px
import plotly.graph_objects as go
import numpy as np

# Configuration de la page
st.set_page_config(
    page_title="Pr√©diction de Prix de T√©l√©phones",
    page_icon="üì±",
    layout="wide"
)

# Titre principal
st.title("üì± Pr√©diction de Prix de T√©l√©phones")
st.markdown("---")

# Chargement des donn√©es et mod√®les
@st.cache_data
def load_data():
    """Charge les donn√©es et mod√®les"""
    try:
        df = pd.read_csv('ndtv_data_final.csv')
        model = joblib.load('phone_price_model.pkl')
        brand_encoder = joblib.load('brand_encoder.pkl')
        processor_encoder = joblib.load('processor_encoder.pkl')
        scaler = joblib.load('scaler.pkl')
        feature_names = joblib.load('feature_names.pkl')
        return df, model, brand_encoder, processor_encoder, scaler, feature_names
    except Exception as e:
        st.error(f"Erreur lors du chargement des donn√©es: {e}")
        return None, None, None, None, None, None

# Chargement des donn√©es
with st.spinner("Chargement des donn√©es..."):
    df, model, brand_encoder, processor_encoder, scaler, feature_names = load_data()

if df is None:
    st.error("Impossible de charger les donn√©es. V√©rifiez que tous les fichiers sont pr√©sents.")
    st.stop()

# Sidebar pour les inputs
st.sidebar.header("üìã Caract√©ristiques du t√©l√©phone")

# R√©cup√©ration des valeurs uniques
brands = sorted(df['Brand'].unique())
processors = sorted(df['Processor'].unique())

# Inputs utilisateur
brand = st.sidebar.selectbox("Marque", brands, help="S√©lectionnez la marque du t√©l√©phone")

col1, col2 = st.sidebar.columns(2)
with col1:
    battery = st.number_input("Batterie (mAh)", min_value=1000, max_value=10000, value=4000, step=100)
    screen_size = st.number_input("Taille √©cran (pouces)", min_value=4.0, max_value=8.0, value=6.1, step=0.1)
    ram = st.number_input("RAM (GB)", min_value=1, max_value=16, value=6, step=1)
    storage = st.number_input("Stockage (GB)", min_value=16, max_value=1024, value=128, step=16)

with col2:
    processor = st.sidebar.selectbox("Processeur (code)", processors, help="Code num√©rique du processeur")
    rear_camera = st.number_input("Cam√©ra arri√®re (MP)", min_value=5, max_value=200, value=48, step=1)
    front_camera = st.number_input("Cam√©ra avant (MP)", min_value=2, max_value=50, value=12, step=1)

# Bouton de pr√©diction
if st.sidebar.button("üöÄ Pr√©dire le Prix", type="primary"):
    
    try:
        # Cr√©ation des fonctionnalit√©s
        camera_total = rear_camera + front_camera
        ram_gb = ram
        ram_mb = ram * 1000
        
        # Calcul des m√©triques moyennes pour l'ing√©nierie des fonctionnalit√©s
        price_per_gb = df['Price'].mean() / df['Internal storage (GB)'].mean()
        price_per_mp = df['Price'].mean() / (df['Rear camera'].mean() + df['Front camera'].mean())
        screen_to_battery_ratio = screen_size / (battery / 1000)
        
        # Pr√©paration des donn√©es d'entr√©e
        input_data = pd.DataFrame({
            'Brand': [brand],
            'Battery capacity (mAh)': [battery],
            'Screen size (inches)': [screen_size],
            'Processor': [processor],
            'RAM (MB)': [ram_mb],
            'Internal storage (GB)': [storage],
            'Rear camera': [rear_camera],
            'Front camera': [front_camera],
            'Camera_Total': [camera_total],
            'RAM_GB': [ram_gb],
            'Price_per_GB': [price_per_gb],
            'Price_per_MP': [price_per_mp],
            'Screen_to_Battery_Ratio': [screen_to_battery_ratio],
            'Price_per_RAM': [price_per_gb],  # Approximation
            'Battery_to_Screen_Ratio': [battery / screen_size]
        })
        
        # Encodage des variables cat√©gorielles
        input_data['Brand'] = brand_encoder.transform(input_data['Brand'])
        input_data['Processor'] = processor_encoder.transform(input_data['Processor'])
        # R√©ordonner les colonnes selon l'ordre d'entra√Ænement
        input_data = input_data[feature_names]
        # Normalisation
        input_scaled = scaler.transform(input_data)
        
        # Pr√©diction brute
        predicted_price = model.predict(input_scaled)[0]

        # Calcul du prix moyen des t√©l√©phones similaires
        similar_phones = df[
            (df['Internal storage (GB)'].between(storage * 0.8, storage * 1.2)) &
            (df['RAM (MB)'].between(ram * 1000 * 0.8, ram * 1000 * 1.2))
        ]
        avg_price = similar_phones['Price'].mean() if not similar_phones.empty else predicted_price

        # --- OPTIMISATION RENFORC√âE ---
        if len(similar_phones) >= 5:
            relative_gap = abs(predicted_price - avg_price) / avg_price
            # Pond√©ration dynamique
            if relative_gap > 0.3:
                model_weight = 0.3
            elif relative_gap > 0.15:
                model_weight = 0.5
            else:
                model_weight = 0.8
            adjusted_price = model_weight * predicted_price + (1 - model_weight) * avg_price

            # Limite stricte : jamais plus de 10% au-dessus de la moyenne
            max_allowed = avg_price * 1.10
            if adjusted_price > max_allowed:
                adjusted_price = max_allowed
                price_note = "(forc√© √† +10% max de la moyenne)"
            else:
                price_note = f"(ajust√© dynamiquement, poids mod√®le: {model_weight:.2f})"
        else:
            adjusted_price = predicted_price
            price_note = "(pas assez de t√©l√©phones similaires pour ajustement)"
        
        # Affichage des r√©sultats
        st.success("‚úÖ Pr√©diction effectu√©e avec succ√®s!")
        
        # M√©triques principales
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric(
                label="üí∞ Prix Pr√©dit",
                value=f"‚Çπ{adjusted_price:,.0f}",
                delta=None,
                help=price_note
            )
        
        with col2:
            st.metric(
                label="üìä Prix Moyen Similaire",
                value=f"‚Çπ{avg_price:,.0f}",
                delta=f"{((adjusted_price - avg_price) / avg_price * 100):.1f}%"
            )
        
        with col3:
            st.metric(
                label="üéØ Pr√©cision Mod√®le",
                value="95.4%",
                delta="+0.2%"
            )
        
        # Graphiques
        st.markdown("---")
        st.subheader("üìà Visualisations")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Graphique en barres - Comparaison des prix
            fig_bar = px.bar(
                x=['Prix Pr√©dit', 'Prix Moyen Similaire'],
                y=[adjusted_price, avg_price],
                title="Comparaison des Prix",
                labels={'x': 'Type de Prix', 'y': 'Prix (‚Çπ)'},
                color=['Prix Pr√©dit', 'Prix Moyen Similaire'],
                color_discrete_map={'Prix Pr√©dit': '#1f77b4', 'Prix Moyen Similaire': '#ff7f0e'}
            )
            fig_bar.update_layout(showlegend=False)
            st.plotly_chart(fig_bar, use_container_width=True)
        
        with col2:
            # Graphique radar - Comparaison des caract√©ristiques
            fig_radar = go.Figure()
            
            # Caract√©ristiques du t√©l√©phone saisi
            fig_radar.add_trace(go.Scatterpolar(
                r=[battery/5000, screen_size/7, ram/8, storage/256, rear_camera/64, front_camera/32],
                theta=['Batterie', '√âcran', 'RAM', 'Stockage', 'Cam. Arri√®re', 'Cam. Avant'],
                fill='toself',
                name='T√©l√©phone Saisi',
                line_color='#1f77b4'
            ))
            
            # Caract√©ristiques moyennes
            fig_radar.add_trace(go.Scatterpolar(
                r=[
                    df['Battery capacity (mAh)'].mean() / 5000,
                    df['Screen size (inches)'].mean() / 7,
                    df['RAM (MB)'].mean() / 8000,
                    df['Internal storage (GB)'].mean() / 256,
                    df['Rear camera'].mean() / 64,
                    df['Front camera'].mean() / 32
                ],
                theta=['Batterie', '√âcran', 'RAM', 'Stockage', 'Cam. Arri√®re', 'Cam. Avant'],
                fill='toself',
                name='Moyenne G√©n√©rale',
                line_color='#ff7f0e'
            ))
            
            fig_radar.update_layout(
                polar=dict(radialaxis=dict(visible=True, range=[0, 1])),
                showlegend=True,
                title="Comparaison des Caract√©ristiques"
            )
            st.plotly_chart(fig_radar, use_container_width=True)
        
        # Informations suppl√©mentaires
        st.markdown("---")
        st.subheader("‚ÑπÔ∏è Informations Compl√©mentaires")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.info(f"""
            **Caract√©ristiques saisies:**
            - Marque: {brand}
            - Batterie: {battery} mAh
            - √âcran: {screen_size} pouces
            - RAM: {ram} GB
            - Stockage: {storage} GB
            - Cam√©ra arri√®re: {rear_camera} MP
            - Cam√©ra avant: {front_camera} MP
            """)
        
        with col2:
            st.info(f"""
            **Statistiques:**
            - T√©l√©phones similaires trouv√©s: {len(similar_phones)}
            - Diff√©rence avec la moyenne: {((adjusted_price - avg_price) / avg_price * 100):.1f}%
            - Prix par GB: ‚Çπ{price_per_gb:.0f}
            - Prix par MP: ‚Çπ{price_per_mp:.0f}
            """)
        
        # Recommandations
        if adjusted_price > avg_price * 1.1:
            st.warning("‚ö†Ô∏è Le prix pr√©dit est sup√©rieur √† la moyenne des t√©l√©phones similaires. V√©rifiez les caract√©ristiques.")
        elif adjusted_price < avg_price * 0.9:
            st.success("‚úÖ Le prix pr√©dit est inf√©rieur √† la moyenne des t√©l√©phones similaires. Bon rapport qualit√©-prix!")
        else:
            st.info("‚ÑπÔ∏è Le prix pr√©dit est dans la moyenne des t√©l√©phones similaires.")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la pr√©diction: {e}")
        st.error("V√©rifiez que toutes les valeurs sont correctes.")

# Footer
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666;'>
    <p>ü§ñ Mod√®le de Machine Learning - Pr√©cision: 95.4%</p>
    <p>üìä Bas√© sur {len(df)} t√©l√©phones dans la base de donn√©es</p>
</div>
""", unsafe_allow_html=True) 